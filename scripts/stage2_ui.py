"""Stage 2 UI: Interactive token-to-player matching interface.

A web-based UI for reviewing ASR tokens and selecting the correct player
for each token from suggestions generated by stage2_match_names.
"""

from __future__ import annotations

import argparse
import csv
import json
from collections import defaultdict
from pathlib import Path
from typing import Any, Dict, List, Optional

from flask import Flask, jsonify, render_template_string, request

app = Flask(__name__)

# Global state
STATE: Dict[str, Any] = {
    "tokens": [],           # First pass tokens
    "suggestions": {},      # token -> list of player suggestions
    "selections": {},       # token_idx -> selected player or None
    "stage2_data": None,    # Full stage2 output
}

HTML_TEMPLATE = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Player Name Matcher</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: #16213e;
            border-radius: 10px;
        }
        header h1 {
            color: #00d4ff;
            margin-bottom: 10px;
        }
        .stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 15px;
        }
        .stat {
            background: #0f3460;
            padding: 10px 20px;
            border-radius: 8px;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #00d4ff;
        }
        .stat-label {
            font-size: 12px;
            color: #888;
        }
        .tokens-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 15px;
        }
        .token-card {
            background: #16213e;
            border-radius: 10px;
            padding: 15px;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        .token-card:hover {
            border-color: #00d4ff;
        }
        .token-card.matched {
            border-color: #00ff88;
            background: #1a3a2e;
        }
        .token-card.no-match {
            border-color: #ff4444;
            background: #2e1a1a;
        }
        .token-card.skipped {
            border-color: #888;
            opacity: 0.6;
        }
        .token-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .token-text {
            font-size: 22px;
            font-weight: bold;
            color: #fff;
        }
        .token-meta {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        .token-index {
            font-size: 12px;
            color: #666;
            background: #0f3460;
            padding: 2px 8px;
            border-radius: 4px;
        }
        .suggestion-count {
            font-size: 11px;
            color: #00d4ff;
            background: #0f3460;
            padding: 2px 8px;
            border-radius: 4px;
        }
        .suggestions-list {
            max-height: 250px;
            overflow-y: auto;
            margin-bottom: 10px;
        }
        .suggestions-list::-webkit-scrollbar {
            width: 6px;
        }
        .suggestions-list::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 3px;
        }
        .suggestion {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px 12px;
            margin: 5px 0;
            background: #0f3460;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s;
        }
        .suggestion:hover {
            background: #1a4a7e;
            transform: translateX(3px);
        }
        .suggestion.selected {
            background: #00d4ff;
            color: #000;
        }
        .suggestion-info {
            flex: 1;
        }
        .suggestion-name {
            font-weight: 600;
            font-size: 14px;
        }
        .suggestion-meta {
            font-size: 11px;
            color: #888;
            margin-top: 2px;
        }
        .suggestion.selected .suggestion-meta {
            color: #333;
        }
        .suggestion-ngrams {
            font-size: 10px;
            color: #666;
            margin-top: 3px;
            font-style: italic;
        }
        .suggestion.selected .suggestion-ngrams {
            color: #444;
        }
        .suggestion-scores {
            text-align: right;
            min-width: 60px;
        }
        .suggestion-career {
            font-size: 14px;
            color: #00d4ff;
            font-weight: bold;
        }
        .suggestion.selected .suggestion-career {
            color: #000;
        }
        .suggestion-match {
            font-size: 10px;
            color: #888;
        }
        .match-type {
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 5px;
            font-weight: 500;
        }
        .match-type.exact {
            background: #00ff88;
            color: #000;
        }
        .match-type.fuzzy {
            background: #ffaa00;
            color: #000;
        }
        .token-actions {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }
        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.15s;
            font-weight: 500;
        }
        .btn-no-match {
            background: #ff4444;
            color: #fff;
            flex: 1;
        }
        .btn-no-match:hover {
            background: #ff6666;
        }
        .btn-skip {
            background: #444;
            color: #fff;
        }
        .btn-skip:hover {
            background: #666;
        }
        .btn-clear {
            background: #333;
            color: #fff;
        }
        .btn-clear:hover {
            background: #555;
        }
        .manual-input {
            display: flex;
            gap: 5px;
            margin-top: 8px;
        }
        .manual-input input {
            flex: 1;
            padding: 8px 10px;
            border: none;
            border-radius: 6px;
            background: #0f3460;
            color: #fff;
            font-size: 13px;
        }
        .manual-input input::placeholder {
            color: #666;
        }
        .manual-input input:focus {
            outline: 2px solid #00d4ff;
        }
        .btn-manual {
            background: #00d4ff;
            color: #000;
            padding: 8px 15px;
        }
        .btn-manual:hover {
            background: #33ddff;
        }
        .selected-player {
            margin-top: 10px;
            padding: 10px;
            background: #00d4ff22;
            border-radius: 6px;
            border-left: 3px solid #00d4ff;
        }
        .selected-player-label {
            font-size: 11px;
            color: #888;
            margin-bottom: 3px;
        }
        .selected-player-name {
            font-weight: bold;
            color: #00d4ff;
            font-size: 15px;
        }
        .no-suggestions {
            color: #888;
            font-style: italic;
            padding: 20px;
            text-align: center;
        }
        .export-section {
            margin-top: 30px;
            text-align: center;
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        .btn-export {
            background: #00ff88;
            color: #000;
            padding: 15px 40px;
            font-size: 16px;
            font-weight: bold;
        }
        .btn-export:hover {
            background: #33ff99;
        }
        .btn-save {
            background: #00d4ff;
            color: #000;
            padding: 15px 40px;
            font-size: 16px;
            font-weight: bold;
        }
        .btn-save:hover {
            background: #33ddff;
        }
        .llm-section {
            margin-top: 15px;
            padding: 10px;
            background: #0f3460;
            border-radius: 6px;
            display: none;
        }
        .llm-section.active {
            display: block;
        }
        .llm-verdict {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .llm-icon {
            font-size: 20px;
        }
        .llm-correct { color: #00ff88; }
        .llm-incorrect { color: #ff4444; }
        .llm-uncertain { color: #ffaa00; }
        .filter-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        .filter-btn {
            padding: 8px 16px;
            background: #0f3460;
            border: none;
            border-radius: 6px;
            color: #fff;
            cursor: pointer;
            transition: all 0.15s;
        }
        .filter-btn:hover {
            background: #1a4a7e;
        }
        .filter-btn.active {
            background: #00d4ff;
            color: #000;
        }
        .search-box {
            margin-left: auto;
            display: flex;
            gap: 10px;
        }
        .search-box input {
            padding: 8px 15px;
            border: none;
            border-radius: 6px;
            background: #0f3460;
            color: #fff;
            width: 200px;
        }
        .search-box input::placeholder {
            color: #666;
        }
        .keyboard-hint {
            font-size: 11px;
            color: #666;
            margin-top: 5px;
        }
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #0f3460;
            border-radius: 4px;
            margin-top: 15px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #00ff88);
            transition: width 0.3s;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        .saving-indicator {
            animation: pulse 1s infinite;
            color: #00d4ff;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>âš½ Player Name Matcher</h1>
            <p>Review ASR tokens and select the correct player for each</p>
            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="total-tokens">0</div>
                    <div class="stat-label">Total Tokens</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="matched-count">0</div>
                    <div class="stat-label">Matched</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="unmatched-count">0</div>
                    <div class="stat-label">No Match</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="pending-count">0</div>
                    <div class="stat-label">Pending</div>
                </div>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill" style="width: 0%"></div>
            </div>
        </header>
        
        <div class="filter-bar">
            <button class="filter-btn active" data-filter="all">All</button>
            <button class="filter-btn" data-filter="pending">Pending</button>
            <button class="filter-btn" data-filter="with-suggestions">With Suggestions</button>
            <button class="filter-btn" data-filter="matched">Matched</button>
            <button class="filter-btn" data-filter="no-match">No Match</button>
            <div class="search-box">
                <input type="text" id="search-input" placeholder="Search tokens...">
            </div>
        </div>
        
        <div class="tokens-grid" id="tokens-grid">
            <!-- Token cards will be inserted here -->
        </div>
        
        <div class="export-section">
            <button class="btn btn-save" onclick="saveSelections()">
                ðŸ’¾ Save Progress
            </button>
            <button class="btn btn-export" onclick="exportSelections()">
                ðŸ“¥ Export JSON
            </button>
        </div>
    </div>
    
    <script>
        let tokensData = [];
        let selections = {};
        let currentFilter = 'all';
        let searchQuery = '';
        
        async function loadData() {
            const response = await fetch('/api/data');
            const data = await response.json();
            tokensData = data.tokens;
            selections = data.selections || {};
            renderTokens();
            updateStats();
        }
        
        function getStatus(idx) {
            const selection = selections[idx];
            if (selection === undefined) return 'pending';
            if (selection === null) return 'no-match';
            if (selection === 'skip') return 'skipped';
            return 'matched';
        }
        
        function renderTokens() {
            const grid = document.getElementById('tokens-grid');
            grid.innerHTML = '';
            
            tokensData.forEach((token, idx) => {
                const status = getStatus(idx);
                const selection = selections[idx];
                const hasSuggestions = token.suggestions && token.suggestions.length > 0;
                
                // Apply filters
                if (currentFilter !== 'all') {
                    if (currentFilter === 'with-suggestions' && !hasSuggestions) return;
                    else if (currentFilter === 'pending' && status !== 'pending') return;
                    else if (currentFilter === 'matched' && status !== 'matched') return;
                    else if (currentFilter === 'no-match' && status !== 'no-match') return;
                }
                
                // Apply search
                if (searchQuery && !token.token.toLowerCase().includes(searchQuery.toLowerCase())) {
                    return;
                }
                
                const card = document.createElement('div');
                card.className = `token-card ${status}`;
                card.id = `token-${idx}`;
                
                const suggestionCount = token.suggestions?.length || 0;
                
                card.innerHTML = `
                    <div class="token-header">
                        <span class="token-text">${escapeHtml(token.token)}</span>
                        <div class="token-meta">
                            <span class="suggestion-count">${suggestionCount} suggestions</span>
                            <span class="token-index">#${idx + 1}</span>
                        </div>
                    </div>
                    <div class="suggestions-list">
                        ${renderSuggestions(token.suggestions, idx, selection)}
                    </div>
                    ${selection && selection !== null && selection !== 'skip' ? `
                        <div class="selected-player">
                            <div class="selected-player-label">âœ“ Selected:</div>
                            <div class="selected-player-name">${escapeHtml(selection)}</div>
                        </div>
                    ` : ''}
                    <div class="manual-input">
                        <input type="text" placeholder="Manual entry..." id="manual-${idx}" 
                               onkeydown="if(event.key==='Enter')manualSelect(${idx})">
                        <button class="btn btn-manual" onclick="manualSelect(${idx})">âœ“</button>
                    </div>
                    <div class="token-actions">
                        <button class="btn btn-no-match" onclick="selectPlayer(${idx}, null)">âœ— No Match</button>
                        <button class="btn btn-skip" onclick="selectPlayer(${idx}, 'skip')">Skip</button>
                        ${selection !== undefined ? `<button class="btn btn-clear" onclick="clearSelection(${idx})">â†© Clear</button>` : ''}
                    </div>
                    <div class="llm-section" id="llm-${idx}">
                        <!-- LLM verdict will go here -->
                    </div>
                `;
                grid.appendChild(card);
            });
        }
        
        function renderSuggestions(suggestions, tokenIdx, currentSelection) {
            if (!suggestions || suggestions.length === 0) {
                return '<div class="no-suggestions">No suggestions found</div>';
            }
            
            return suggestions.slice(0, 15).map((s, i) => {
                const isSelected = currentSelection === s.name;
                const ngrams = s.source_ngrams || [];
                const ngramText = ngrams.length > 0 ? ngrams.slice(0, 2).join(', ') + (ngrams.length > 2 ? '...' : '') : '';
                
                return `
                    <div class="suggestion ${isSelected ? 'selected' : ''}" 
                         onclick="selectPlayer(${tokenIdx}, '${escapeJs(s.name)}')"
                         title="${escapeHtml(s.player?.full_name || s.name)}">
                        <div class="suggestion-info">
                            <span class="suggestion-name">${escapeHtml(s.name)}</span>
                            <span class="match-type ${s.match_type}">${s.match_type === 'exact' ? 'âœ“ exact' : 'â‰ˆ fuzzy'}</span>
                            <div class="suggestion-meta">
                                ${s.player?.position || ''} ${s.player?.position && s.player?.current_club ? '|' : ''} ${s.player?.current_club || ''}
                                ${s.player?.nationality ? `| ${s.player.nationality}` : ''}
                            </div>
                            ${ngramText ? `<div class="suggestion-ngrams">from: ${escapeHtml(ngramText)}</div>` : ''}
                        </div>
                        <div class="suggestion-scores">
                            <div class="suggestion-career">${s.career_score?.toFixed(0) || '0'}</div>
                            <div class="suggestion-match">${s.score || 0}% match</div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        async function selectPlayer(tokenIdx, playerName) {
            selections[tokenIdx] = playerName;
            
            await fetch('/api/select', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({token_idx: tokenIdx, player_name: playerName})
            });
            
            renderTokens();
            updateStats();
        }
        
        async function clearSelection(tokenIdx) {
            delete selections[tokenIdx];
            
            await fetch('/api/select', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({token_idx: tokenIdx, player_name: '__clear__'})
            });
            
            renderTokens();
            updateStats();
        }
        
        function manualSelect(tokenIdx) {
            const input = document.getElementById(`manual-${tokenIdx}`);
            const value = input.value.trim();
            if (value) {
                selectPlayer(tokenIdx, value);
            }
        }
        
        function updateStats() {
            const total = tokensData.length;
            let matched = 0, noMatch = 0, pending = 0;
            
            tokensData.forEach((_, idx) => {
                const sel = selections[idx];
                if (sel === undefined) pending++;
                else if (sel === null) noMatch++;
                else if (sel !== 'skip') matched++;
            });
            
            document.getElementById('total-tokens').textContent = total;
            document.getElementById('matched-count').textContent = matched;
            document.getElementById('unmatched-count').textContent = noMatch;
            document.getElementById('pending-count').textContent = pending;
            
            // Update progress bar
            const completed = matched + noMatch;
            const progress = total > 0 ? (completed / total * 100) : 0;
            document.getElementById('progress-fill').style.width = `${progress}%`;
        }
        
        async function saveSelections() {
            const response = await fetch('/api/save', {method: 'POST'});
            const data = await response.json();
            if (data.status === 'ok') {
                alert(`Saved ${data.count} selections to ${data.path}`);
            }
        }
        
        async function exportSelections() {
            const response = await fetch('/api/export');
            const data = await response.json();
            
            const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'player_selections.json';
            a.click();
        }
        
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function escapeJs(text) {
            if (!text) return '';
            return text.replace(/'/g, "\\'").replace(/"/g, '\\"');
        }
        
        // Filter buttons
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentFilter = btn.dataset.filter;
                renderTokens();
            });
        });
        
        // Search input
        document.getElementById('search-input').addEventListener('input', (e) => {
            searchQuery = e.target.value;
            renderTokens();
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === '/' && document.activeElement.tagName !== 'INPUT') {
                e.preventDefault();
                document.getElementById('search-input').focus();
            }
        });
        
        // Load data on page load
        loadData();
    </script>
</body>
</html>
"""


def load_tokens_csv(path: Path) -> List[Dict[str, Any]]:
    """Load tokens from CSV, return only first pass."""
    tokens = []
    with open(path, newline="", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        for row in reader:
            if int(row.get("pass", 1)) == 1:
                tokens.append({
                    "token": row.get("token", ""),
                    "segment_start": float(row.get("segment_start", 0)),
                    "segment_end": float(row.get("segment_end", 0)),
                })
    return tokens


def load_stage2_matches(path: Path) -> Dict[str, Any]:
    """Load stage2 match results."""
    return json.loads(path.read_text(encoding="utf-8"))


def normalize_token(text: str) -> str:
    """Normalize token text for comparison."""
    import re
    text = text.lower()
    parts = re.findall(r"[a-z0-9]+", text)
    return " ".join(parts).strip()


def build_token_suggestions(tokens: List[Dict], stage2_data: Dict) -> Dict[int, List[Dict]]:
    """Build suggestions for each token from stage2 matches.
    
    Aggregates all suggestions from n-grams that include each token,
    across all passes, and ranks by career score.
    """
    # Map token index -> all suggestions (by player name)
    token_suggestions: Dict[int, Dict[str, Dict]] = defaultdict(dict)
    
    # Build a lookup for pass 1 token text -> indices
    token_text_to_indices: Dict[str, List[int]] = defaultdict(list)
    for idx, tok in enumerate(tokens):
        norm = normalize_token(tok["token"])
        if norm:
            token_text_to_indices[norm].append(idx)
    
    matches = stage2_data.get("matches", [])
    
    for match in matches:
        pass_num = match.get("pass", 1)
        indices = match.get("token_indices", [])
        ngram = match.get("ngram", "")
        suggestions_list = match.get("suggestions", [])
        
        if not indices or len(indices) < 2:
            continue
            
        start_idx, end_idx = indices[0], indices[1]
        
        # Process each suggestion
        for suggestion in suggestions_list:
            name = suggestion.get("name", "")
            if not name:
                continue
            
            key = name.lower()
            
            if pass_num == 1:
                # Direct mapping for pass 1
                for idx in range(start_idx, end_idx + 1):
                    if idx < len(tokens):
                        if key not in token_suggestions[idx]:
                            token_suggestions[idx][key] = {**suggestion, "source_ngrams": [ngram]}
                        else:
                            existing = token_suggestions[idx][key]
                            # Track all source ngrams
                            if ngram not in existing.get("source_ngrams", []):
                                existing.setdefault("source_ngrams", []).append(ngram)
                            # Keep higher score
                            if (suggestion.get("career_score") or 0) > (existing.get("career_score") or 0):
                                existing.update(suggestion)
            else:
                # For other passes, match by normalized token text
                ngram_tokens = ngram.split()
                for ng_token in ngram_tokens:
                    matched_indices = token_text_to_indices.get(ng_token, [])
                    for idx in matched_indices:
                        if key not in token_suggestions[idx]:
                            token_suggestions[idx][key] = {**suggestion, "source_ngrams": [ngram], "source_passes": [pass_num]}
                        else:
                            existing = token_suggestions[idx][key]
                            if ngram not in existing.get("source_ngrams", []):
                                existing.setdefault("source_ngrams", []).append(ngram)
                            if pass_num not in existing.get("source_passes", []):
                                existing.setdefault("source_passes", []).append(pass_num)
                            if (suggestion.get("career_score") or 0) > (existing.get("career_score") or 0):
                                existing.update(suggestion)
    
    # Convert to sorted lists
    result: Dict[int, List[Dict]] = {}
    for idx, suggestions_dict in token_suggestions.items():
        sorted_suggestions = sorted(
            suggestions_dict.values(),
            key=lambda s: (s.get("career_score") or 0),
            reverse=True
        )
        result[idx] = sorted_suggestions
    
    return result


@app.route("/")
def index():
    return render_template_string(HTML_TEMPLATE)


@app.route("/api/data")
def get_data():
    tokens_with_suggestions = []
    for idx, token in enumerate(STATE["tokens"]):
        tokens_with_suggestions.append({
            **token,
            "suggestions": STATE["suggestions"].get(idx, [])
        })
    
    return jsonify({
        "tokens": tokens_with_suggestions,
        "selections": STATE["selections"]
    })


@app.route("/api/select", methods=["POST"])
def select_player():
    data = request.json
    token_idx = data.get("token_idx")
    player_name = data.get("player_name")
    
    if player_name == "__clear__":
        STATE["selections"].pop(token_idx, None)
    else:
        STATE["selections"][token_idx] = player_name
    
    return jsonify({"status": "ok"})


@app.route("/api/save", methods=["POST"])
def save_selections():
    """Save selections to a JSON file."""
    output_path = STATE.get("output_path", "out/selections.json")
    
    result = []
    for idx, token in enumerate(STATE["tokens"]):
        selection = STATE["selections"].get(idx)
        if selection is not None:  # Only save if there's a selection (including null for "no match")
            result.append({
                "index": idx,
                "token": token["token"],
                "selected_player": selection,
            })
    
    Path(output_path).parent.mkdir(parents=True, exist_ok=True)
    Path(output_path).write_text(
        json.dumps({"selections": result}, ensure_ascii=False, indent=2),
        encoding="utf-8"
    )
    
    return jsonify({"status": "ok", "count": len(result), "path": output_path})


@app.route("/api/export")
def export_selections():
    result = []
    for idx, token in enumerate(STATE["tokens"]):
        selection = STATE["selections"].get(idx)
        result.append({
            "index": idx,
            "token": token["token"],
            "selected_player": selection,
            "suggestions": STATE["suggestions"].get(idx, [])[:5]  # Top 5 only
        })
    
    return jsonify({
        "tokens": result,
        "summary": {
            "total": len(STATE["tokens"]),
            "matched": sum(1 for s in STATE["selections"].values() if s and s != "skip" and s is not None),
            "no_match": sum(1 for s in STATE["selections"].values() if s is None),
            "skipped": sum(1 for s in STATE["selections"].values() if s == "skip"),
        }
    })


def main():
    parser = argparse.ArgumentParser(description="Interactive UI for token-to-player matching")
    parser.add_argument("--tokens-csv", required=True, help="Stage1 tokens CSV file")
    parser.add_argument("--stage2-json", required=True, help="Stage2 matches JSON file")
    parser.add_argument("--port", type=int, default=5000, help="Port to run server on")
    parser.add_argument("--host", default="127.0.0.1", help="Host to bind to")
    parser.add_argument("--selections", help="Load previous selections from JSON")
    parser.add_argument("--output", default="out/selections.json", help="Output path for saving selections")
    args = parser.parse_args()
    
    # Store output path in state
    STATE["output_path"] = args.output
    
    # Load data
    print(f"Loading tokens from {args.tokens_csv}...")
    STATE["tokens"] = load_tokens_csv(Path(args.tokens_csv))
    print(f"  Loaded {len(STATE['tokens'])} tokens from pass 1")
    
    print(f"Loading stage2 matches from {args.stage2_json}...")
    STATE["stage2_data"] = load_stage2_matches(Path(args.stage2_json))
    print(f"  Loaded {len(STATE['stage2_data'].get('matches', []))} matches")
    
    print("Building token suggestions...")
    STATE["suggestions"] = build_token_suggestions(STATE["tokens"], STATE["stage2_data"])
    tokens_with_suggestions = sum(1 for s in STATE["suggestions"].values() if s)
    print(f"  {tokens_with_suggestions} tokens have suggestions")
    
    # Load previous selections if provided
    if args.selections and Path(args.selections).exists():
        print(f"Loading previous selections from {args.selections}...")
        prev = json.loads(Path(args.selections).read_text())
        for item in prev.get("selections", prev.get("tokens", [])):
            idx = item.get("index")
            sel = item.get("selected_player")
            if idx is not None:
                STATE["selections"][idx] = sel
        print(f"  Loaded {len(STATE['selections'])} selections")
    
    print(f"\nðŸš€ Starting server at http://{args.host}:{args.port}")
    print("   Press Ctrl+C to stop\n")
    
    app.run(host=args.host, port=args.port, debug=False)


if __name__ == "__main__":
    main()
